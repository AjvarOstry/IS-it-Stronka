# 4.1 Poprawka
```bash
###
ps -o pid,vsz,rsz -p PID - ilość ramek i stron
###
echo bfq > /sys/block/sda/queue/scheduler
dd if=/dev/sda of=/dev/null bs=1G count=100 & # lub jak za szybko
dd if=/dev/sda of=/dev/null &
pmap -x 20754
20754:   dd if=/dev/sda of=/dev/null bs=1G count=100
# Adres   rozmiar stron rozmiar ramek zabrudzone 
Address           Kbytes     RSS   Dirty Mode  Mapping
0000560d99d91000      40      40       0 r-x-- dd #segment z pliku
0000560d99d9b000      20      20       0 r---- dd 
0000560d99da0000       4       4       4 r---- dd
0000560d99da1000       4       4       4 rw--- dd
0000560dc0683000     132      16      16 rw---   [ anon ] #sterta
00007f0b367fe000 1048584 1048580 1048580 rw---   [ anon ] # bufor zalokowany dynamicznie tworzony przez bs=1G
00007f0b76800000  226908     416       0 r---- locale-archive
00007f0b8466c000     360     192       0 r---- coreutils.mo
00007f0b846c6000      12       8       8 rw---   [ anon ]
00007f0b846c9000       4       4       0 r---- libc.so.6
00007f0b846ca000    1468     996       0 r-x-- libc.so.6 # rozmiar 1468, ale tylko 996 zalokowane od pamięci
00007f0b84839000     468     328       0 r---- libc.so.6
00007f0b848ae000      16      16      16 r---- libc.so.6
00007f0b848b2000       8       8       8 rw--- libc.so.6
00007f0b848b4000      40      24      24 rw---   [ anon ]
00007f0b848d0000      28      28       0 r--s- gconv-modules.cache
00007f0b848d7000       8       0       0 r----   [ anon ]
00007f0b848d9000       8       0       0 r----   [ anon ]
00007f0b848db000       8       8       0 r-x--   [ anon ]
00007f0b848dd000       4       4       0 r---- ld-linux-x86-64.so.2 #biblioteka
00007f0b848de000     164     164       0 r-x-- ld-linux-x86-64.so.2
00007f0b84907000      44      44       0 r---- ld-linux-x86-64.so.2
00007f0b84912000       8       8       8 r---- ld-linux-x86-64.so.2
00007f0b84914000       8       8       8 rw--- ld-linux-x86-64.so.2
00007ffed70d2000     132      16      16 rw---   [ stack ] #stos
ffffffffff600000       4       0       0 --x--   [ anon ]
---------------- ------- ------- ------- 
total kB         1278484 1050936 1048692

free -k # pamięć dostępna w trybie nieuprzywilejowanym
#kolumna total wiersz Mem
               total        used        free      shared  buff/cache   available
Mem:         8088064     2471308     1270548        7736     4773384     5616756 
Swap:        8087548         764     8086784
```

```bash
### Eksperyment do zadania 20 ###
# Terminal 1
which nano
/usr/bin/nano
cp /usr/bin/nano /home/sysop/nano
file /home/sysop/nano 
/home/sysop/nano: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=234eb7d3646eff02d31a29c4176f223f55eb89d8, for GNU/Linux 3.2.0, stripped
#terminal 2
/home/sysop/nano 

#terminal 1
pidof nano
22570
stat -f /home
  Plik: "/home"
    ID: dd47b0d54e281a54 długość nazwy: 255     typ: ext2/ext3
rozmiar bloku: 4096       podstawowy rozmiar bloku: 4096
bloków: Razem: 755402     wolnych: 711510     dostępnych: 668093
Inody: razem: 196608     wolnych: 194206

rm -r /home/sysop/nano
stat -f /home
  Plik: "/home"
    ID: dd47b0d54e281a54 długość nazwy: 255     typ: ext2/ext3
rozmiar bloku: 4096       podstawowy rozmiar bloku: 4096
bloków: Razem: 755402     wolnych: 711510     dostępnych: 668093
Inody: razem: 196608     wolnych: 194206

kill 22570
stat -f /home # tu będzie więcej wolnych, ale mi się nie chciało
  Plik: "/home"
    ID: dd47b0d54e281a54 długość nazwy: 255     typ: ext2/ext3
rozmiar bloku: 4096       podstawowy rozmiar bloku: 4096
bloków: Razem: 755402     wolnych: 711510     dostępnych: 668093
Inody: razem: 196608     wolnych: 194206
```

```bash
### Eksperyment do zadania 21 ###
free -w
               total        used        free      shared     buffers       cache   available
Mem:         8088032     1900724     5255492        7752        7376     1300784     6187308
Swap:        8087548           0     8087548
```

czas wirtualny życia procesu,
strony i ramki



10. Czy całość jego kodu i danych jest wczytywana z pliku programu ELF oraz plików bibliotek ELF do fizycznej pamięci ulotnej?  - wymagane zaprezentowania odpowiednich wartości dla przykładowego nieanonimowego segmentu danych i segmentów tekstu w listingu z mapą pamięci procesu jednowątkowego, gdzie nie wszystkie strony segmentu są załadowane do ramek.

Nie. Część kodu/danych pochodzi z segmentów anonimowych
dane r—- lub rw—-   tekst / kod r-x——-
Kbytes / Size (rozmiar wirtualny): – cały segment mapowany z pliku libc.so.6. (wszystkie strony)
Rss (Resident Set Size): – część segmentu załadowana do fizycznej pamięci RAM. (ramki)
Pss (Proportional Set Size): – uwzględnia współdzielone strony z innymi procesami.

segmentacja i stronicowanie 
Dlaczego nie wszystkie strony są w RAM? - Optymalizacja zasobów: System nie ładuje nieużywanych części kodu/danych (np. rzadko używane funkcje).
Z jakich elementów składa się przestrzeń adresowa procesu?
Z segmentów pamięci. Przechowują one dane, kod/tekst, stertę, stos…
Jakie strony procesu są załadowane do ramki? - Tylko te potrzebne.
Jak nazywa się zbiór ramek procesu? - Zbiór roboczy

12. Jaki rozmiar zajmują wszystkie strony procesu a jaki wszystkie przydzielone dla procesu ramki oraz jak nazywa się sytuacja, gdy potrzebna strona nie znajduje się w ramce procesu (należy wymienić możliwe warianty tej sytuacji oraz gdzie system będzie szukał potrzebnej strony)?  - wymagane wskazanie odpowiednich wartości w listingach.

Wskazanie łącznego rozmiaru wszystkich stron i ramek
strony - total Kbytes, cała pamięć do której proces ma dostęp,
ramki - total RSS, nie uwzględnia swap, ale uwzględnia pamięć bibliotek
współdzielonych, czyli pokazuje tylko aktualny stan ramek w pamięci fizycznej

**Błąd braku strony** - zgłasza go proces, obsługuje system
System będzie szukał w:
- swap cache - Błąd poboczny, aktualizacja zbioru roboczego
- w przestrzeni wymiany
- w plikach programu / bibliotekach

20. Jeżeli plik zawierający program/bibliotekę ELF zostanie usunięty, to skąd system operacyjny będzie doczytywał potrzebne strony, jaki jest związek pomiędzy niezwolnionymi blokami systemu plików a stronami? - omówienie statystyk węzłów i bloków systemu plików, aby stwierdzić czy po usunięciu pliku zostały one zwolnione wraz z usuniętym wpisem katalogowym.

System nadal będzie w stanie wczytać stronę z usuniętego pliku
dostępne bloki i węzły się nie zwolnią, póki nie zakończymy procesu
Kto blokuje zwolnienie bloków? - mechanizm pamięci wirtualnej
Dlaczego? - system operacyjny musi mieć możliwość wczytania
Skąd? - ze swap cache. Ramki ze stronami nieaktywnymi, niezabrudzonymi, nieanonimowymi
Jakbyśmy w ramkę wczytali nową stronę - doszłoby do utraty danych
gdzie system utrwala - do przestrzeni wymiany. Wtedy przestaje być zabrudzona
strona jest nieaktywna - nie było ostatnio odwołania do tej strony

21. Z jakiego obszaru pamięci ulotnej wybierane są niepuste ramki i jakie kryteria musi spełniać ramka wybrana przez algorytm wymiany? - analiza wyników free –w dotycząca różnicy w wartościach pomiędzy kolumną free i available w wierszu mem. 

**free** - pamięć zupełnie nieużywana (wolne ramki)
**available** - wolne ramki wraz z ramkami ze swap cache(niezabrodzone, nieanonimowe) i części buforów, które system jest w stanie zwolnić w razie potrzeby - czyli ze stronami niezabrudzonymi
bufor - pamięć pomocnicza - pliki z danymi na których pracuje proces np otwarty dokument

24. Jakie zasoby systemowe trzeba monitorować i jakie działania można podjąć aby procedura OOM nie była zastosowana? - wymagane zaprezentowanie odpowiednich wartości w listingach.

Monitorować stan dostępnej pamięci operacyjnej oraz przestrzeni wymiany
da się zrezygnować z przestrzeni wymiany, ale to nie jest dobry pomysł, bo dużo trudniej kontrolować, czy za raz dojdzie do OOM
Na częsci systemów operacyjnych można zwiększyć rozmiar swap, ale zawsze można ręcznie pozabijać wybrane procesy
